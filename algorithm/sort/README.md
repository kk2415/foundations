# 버블 정렬 알고리즘
버블 정렬의 성능을 결정하는 요소는 두 데이터간의 비교연산이 수행된 횟수이다.

버블 정렬에서 데이터 수가 𝑛개일 때 진행되는 비교 횟수의 합은 등차수열의 합으로 나타낼 수 있다. 버블 정렬은 각 단계에서 가장 큰 값을 끝으로 이동시키고, 이를 𝑛−1번 반복합니다. 각 단계에서 비교 횟수는 1씩 점점 줄어든다.

첫 번째 패스에서는 𝑛−1번의 비교가 일어나고, 두 번째 패스에서는 𝑛−2번의 비교가 일어나며, 마지막에는 1번의 비교가 일어난다. 이를 등차수열로 나타내면 다음과 같다

$$ (n + 1) + (n + 2) + (n + 3) + \cdots + 2 + 1 $$

등차수열의 합 공식을 이용하면 아래와 같다.

$$
\begin{align*}
	& (n - 1) + 1 \times  \frac{(n - 1)}{2} \\
	& = \frac{n(n - 1)}{2} \\
	& = \frac{n^2-n}{2}
\end{align*}
$$

$$
\begin{align*}
	& T\left (n  \right ) = \frac{n^2-n}{2} \\
	& O\left ( n^2 \right )
\end{align*}
$$

# 선택 정렬 알고리즘
선택 정렬 알고리즘은 우선순위가 제일 큰 요소를 선택해서 첫 번째 위치에 옮기고 그 다음에 두 번째로 우선순위가 큰 요소를 집어서(선택해서) 두 번째 위치에 옮기는 작업을 배열 길이 만큼 반복하는 알고리즘이다.

실제 정렬 작업은 두 데이터간의 교환으로 진행되지만 이것은 데이터를 선택해서 옮길 때 마다 비게되는 공간을 활용하는 것이란 걸 이해해야한다.

비교연산 횟수를 기준으로 선택 정렬 알고리즘의 시간 복잡도는 다음과 같다.

$$
\begin{align*}
	& T\left (n  \right ) = \frac{n^2-n}{2} \\
	& O\left ( n^2 \right )
\end{align*}
$$

# 삽입 정렬 알고리즘
정렬할 요소를 적절한 위치에 삽입해 가면서 정렬을 진행하는 알고리즘.

정렬할 배열을 두 부분으로 나눠서 인식하자. 정렬이 된 부분과 정렬이 안된 부분.
정렬이 된 부분의 바로 다음에 위치한 데이터가 정렬 대상이다.
정렬이 된 부분의 맨 끝에서부터 정렬 대상과 대소 비교한다. 정렬 대상보다 작은 값을 만날 때 까지 1씩 줄여가며 반복한다. 만약 n번째 항에서 정렬 대상보다 큰 값을 만나면 n번째항의 요소를 n + 1항 요소에 넣어준다. 결과적으로 n번째 요소와 n + 1번째 요소는 값이 같게된다. n번째 위치에서 정렬대상보다 작은 값을 만나면 n + 1번째 요소에 정렬대상을 삽입한다.

비교연산 횟수를 기준으로 삽입 정렬 알고리즘의 시간 복잡도는 다음과 같다.

$$ O\left ( n^2 \right ) $$

# 힙 정렬 알고리즘
힙 자료구조를 이용한 정렬 알고리즘. 힙 자료구조는 루트 노드에 저장된 값이 정렬순서상 가장 앞선다. 배열에 저장된 데이터를 순서대로 힙에 저장하면 힙의 특성에 의해 자동으로 정렬이 된다. 그 다음에 힙에 저장된 데이터를 루트 노드부터 하나씩 배열에 첫번째 요소부터 마지막요소까지 저장하면 정렬이 완료된다. 아래는 시간 복잡도 설명이다.

**힙 자료구조의 삽입 시간 복잡도:**: $\;O\left ( log_{2}n \right )$  
**힙 자료구조의 삭제 시간 복잡도:**: $\;O\left ( log_{2}n \right )$  

삽입과 삭제를 하나로 묶은 연산의 시간 복잡도는 $\;O\left ( 2log_{2}n \right )\;$이 되겠지만 빅-$O$ 표기법에서 상수 2는 무시할만한 사이즈이기 때문에 시간 복잡도는 $\;O\left ( log_{2}n \right )\;$가 된다. 여기서 연산이 총 $\;n$번 진행되기 때문에 $\;n$을 곱해서 최종적으로 힙 정렬의 시간 복잡도는 다음과 같다:

$$ O\left ( nlog_{2}n \right ) $$

# 병합 정렬 알고리즘
분할 정복(divide and conquer) 알고리즘을 기반으로 만들어진 정렬 알고리즘이다. 분할 정복이란 크고 방대한 문제를 작은 단위로 나눠가며 해결하고 다시 합쳐나감으로써 결과를 도출하는 접근법을 말한다.  

병합 정렬은 우선 정렬할 배열을 더이상 분할할 수 없을 때 까지 분할해나간다. 더이상 분할할 수 없는 그 기준점은 무엇일까. 정렬할 배열을 분할할 수 없다는 건 그 배열이 원소를 1개만 가지고 있다는 뜻이다. 길이가 1인 배열은 더이상 분할할 수 없다. 한 개의 배열 원소를 둘로 쪼갤 수는 없다.  

분할이라는 단어를 써서 마치 하나의 배열을 n개의 배열로 쪼갤 것 같지만 실제 구현은 계속 하나의 배열을 사용한다. 하나의 배열에서 일정한 간격의 구간을 구분짓는 인덱스를 계속 늘려가는 과정이다. 그 인덱스가 배열 모든 요소 하나하나를 가리키면 분할은 끝난다. 이미 배열의 요소를 가리키는 인덱스 하나하나가 모든 요소를 한개씩 맡고있는데 인덱스를 늘려봤자 새로 생긴 인덱스는 가리킬 수 있는 배열 요소가 없다.  

배열의 첫 번째 요소를 가리키는 인덱스가 left고 마지막 요소를 가리키는 인덱스가 right이면 left와 right가 $n$과 $n+1$ 관계가 될 때까지 분할한다.

병합 정렬의 시간복잡도는 다음과 같다.

$$ O\left ( nlog_{2}n \right ) $$