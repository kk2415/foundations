# 버블 정렬 알고리즘
버블 정렬(Bubble Sort)은 비교 기반의 단순한 정렬 알고리즘이다. 인접한 두 요소를 비교하여 필요한 경우 서로 교환하면서 리스트를 정렬한다. 이 과정은 리스트가 정렬될 때까지 반복된다. 버블 정렬의 이름은 정렬 과정에서 큰 값이 "거품"처럼 리스트의 끝으로 이동하는 데서 유래했다.

버블 정렬의 성능을 결정하는 요소는 두 데이터간의 비교연산이 수행된 횟수이다.

$$
\begin{align*}
	& O\left ( n^2 \right )
\end{align*}
$$

# 선택 정렬 알고리즘
선택 정렬 알고리즘은 우선순위가 제일 큰 요소를 선택해서 첫 번째 위치에 옮기고 그 다음에 두 번째로 우선순위가 큰 요소를 집어서(선택해서) 두 번째 위치에 옮기는 작업을 배열 길이 만큼 반복하는 알고리즘이다.

실제 정렬 작업은 두 데이터간의 교환으로 진행되지만 이것은 데이터를 선택해서 옮길 때 마다 비게되는 공간을 활용하는 것이란 걸 이해해야한다.

비교연산 횟수를 기준으로 선택 정렬 알고리즘의 시간 복잡도는 다음과 같다.

$$
\begin{align*}
	& O\left ( n^2 \right )
\end{align*}
$$

# 삽입 정렬 알고리즘
정렬할 요소를 적절한 위치에 삽입해 가면서 정렬을 진행하는 알고리즘.

비교연산 횟수를 기준으로 삽입 정렬 알고리즘의 시간 복잡도는 다음과 같다.

$$ O\left ( n^2 \right ) $$

# 힙 정렬 알고리즘
힙 자료구조를 이용한 정렬 알고리즘. 힙 자료구조는 루트 노드에 저장된 값이 정렬순서상 가장 앞선다. 배열에 저장된 데이터를 순서대로 힙에 저장하면 힙의 특성에 의해 자동으로 정렬이 된다. 그 다음에 힙에 저장된 데이터를 루트 노드부터 하나씩 배열에 첫번째 요소부터 마지막요소까지 저장하면 정렬이 완료된다.

힙 정렬의 시간 복잡도는 다음과 같다:

$$ O\left ( nlog_{2}n \right ) $$

# 병합 정렬 알고리즘
병합 정렬은 분할 정복(divide and conquer) 알고리즘을 기반으로 만들어진 정렬 알고리즘이다. 분할 정복이란, 말 그대로 복잡한 문제를 복잡하지 않은 문제로 분할하여 정복하는 방법이다.

병합 정렬의 시간복잡도는 다음과 같다.

$$ O\left ( nlog_{2}n \right ) $$

# 퀵 정렬 알고리즘
퀵 정렬은 분할 정복(divide and conquer) 알고리즘을 기반으로 만들어진 정렬 알고리즘이다. 분할 정복이란, 말 그대로 복잡한 문제를 복잡하지 않은 문제로 분할하여 정복하는 방법이다.

퀵 정렬의 시간 복잡도는 다음과 같다.

$$ O\left ( nlog_{2}n \right ) $$

# 기수 정렬 알고리즘
기수 정렬(Radix Sort)은 비교 기반 정렬 알고리즘이 아니며, 데이터의 개별 자릿수를 기준으로 정렬하는 방법이다. 이 알고리즘은 주로 정수나 문자열 같은 고정된 길이의 데이터에 유용하다. 기수 정렬은 LSD (Least Significant Digit)와 MSD (Most Significant Digit) 두 가지 방법으로 구현될 수 있다. 여기서는 더 일반적인 LSD 방식을 설명한다.

시간 복잡도는 다음과 같다.

$$
O\left(n\right)
$$