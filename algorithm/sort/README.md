# 버블 정렬 알고리즘
버블 정렬의 성능을 결정하는 요소는 두 데이터간의 비교연산이 수행된 횟수이다.

버블 정렬에서 데이터 수가 𝑛개일 때 진행되는 비교 횟수의 합은 등차수열의 합으로 나타낼 수 있다. 버블 정렬은 각 단계에서 가장 큰 값을 끝으로 이동시키고, 이를 𝑛−1번 반복합니다. 각 단계에서 비교 횟수는 1씩 점점 줄어든다.

첫 번째 패스에서는 𝑛−1번의 비교가 일어나고, 두 번째 패스에서는 𝑛−2번의 비교가 일어나며, 마지막에는 1번의 비교가 일어난다. 이를 등차수열로 나타내면 다음과 같다

$$ (n + 1) + (n + 2) + (n + 3) + \cdots + 2 + 1 $$

등차수열의 합 공식을 이용하면 아래와 같다.

$$
\begin{align*}
	& (n - 1) + 1 \times  \frac{(n - 1)}{2} \\
	& = \frac{n(n - 1)}{2} \\
	& = \frac{n^2-n}{2}
\end{align*}
$$

$$
\begin{align*}
	& T\left (n  \right ) = \frac{n^2-n}{2} \\
	& O\left ( n^2 \right )
\end{align*}
$$

# 선택 정렬 알고리즘
선택 정렬 알고리즘은 우선순위가 제일 큰 요소를 선택해서 첫 번째 위치에 옮기고 그 다음에 두 번째로 우선순위가 큰 요소를 집어서(선택해서) 두 번째 위치에 옮기는 작업을 배열 길이 만큼 반복하는 알고리즘이다.

실제 정렬 작업은 두 데이터간의 교환으로 진행되지만 이것은 데이터를 선택해서 옮길 때 마다 비게되는 공간을 활용하는 것이란 걸 이해해야한다.

비교연산 횟수를 기준으로 선택 정렬 알고리즘의 시간 복잡도는 다음과 같다.

$$
\begin{align*}
	& T\left (n  \right ) = \frac{n^2-n}{2} \\
	& O\left ( n^2 \right )
\end{align*}
$$

# 삽입 정렬 알고리즘
정렬할 요소를 적절한 위치에 삽입해 가면서 정렬을 진행하는 알고리즘.

정렬할 배열을 두 부분으로 나눠서 인식하자. 정렬이 된 부분과 정렬이 안된 부분.
정렬이 된 부분의 바로 다음에 위치한 데이터가 정렬 대상이다.
정렬이 된 부분의 맨 끝에서부터 정렬 대상과 대소 비교한다. 정렬 대상보다 작은 값을 만날 때 까지 1씩 줄여가며 반복한다. 만약 n번째 항에서 정렬 대상보다 큰 값을 만나면 n번째항의 요소를 n + 1항 요소에 넣어준다. 결과적으로 n번째 요소와 n + 1번째 요소는 값이 같게된다. n번째 위치에서 정렬대상보다 작은 값을 만나면 n + 1번째 요소에 정렬대상을 삽입한다.

비교연산 횟수를 기준으로 삽입 정렬 알고리즘의 시간 복잡도는 다음과 같다.

$$ O\left ( n^2 \right ) $$

# 힙 정렬 알고리즘
힙 자료구조를 이용한 정렬 알고리즘. 힙 자료구조는 루트 노드에 저장된 값이 정렬순서상 가장 앞선다. 배열에 저장된 데이터를 순서대로 힙에 저장하면 힙의 특성에 의해 자동으로 정렬이 된다. 그 다음에 힙에 저장된 데이터를 루트 노드부터 하나씩 배열에 첫번째 요소부터 마지막요소까지 저장하면 정렬이 완료된다. 아래는 시간 복잡도 설명이다.

**힙 자료구조의 삽입 시간 복잡도:**: $\;O\left ( log_{2}n \right )$  
**힙 자료구조의 삭제 시간 복잡도:**: $\;O\left ( log_{2}n \right )$  

삽입과 삭제를 하나로 묶은 연산의 시간 복잡도는 $\;O\left ( 2log_{2}n \right )\;$이 되겠지만 빅-$O$ 표기법에서 상수 2는 무시할만한 사이즈이기 때문에 시간 복잡도는 $\;O\left ( log_{2}n \right )\;$가 된다. 여기서 연산이 총 $\;n$번 진행되기 때문에 $\;n$을 곱해서 최종적으로 힙 정렬의 시간 복잡도는 다음과 같다:

$$ O\left ( nlog_{2}n \right ) $$

# 병합 정렬 알고리즘
병합 정렬은 분할 정복(divide and conquer) 알고리즘을 기반으로 만들어진 정렬 알고리즘이다. 분할 정복이란, 말 그대로 복잡한 문제를 복잡하지 않은 문제로 분할하여 정복하는 방법이다.

병합 정렬은 우선 정렬할 배열을 더이상 분할할 수 없을 때 까지 분할해나간다. 분할이라는 단어를 써서 마치 하나의 배열을 $n$개의 배열로 쪼갤 것 같지만 실제 구현은 계속 하나의 배열을 사용한다. 하나의 배열을 두 개의 배열로 구분 짓는 인덱스를 계속 늘려가는 
과정이 분할이다. 그 인덱스가 배열 모든 요소 하나하나를 가리키면 분할은 끝난다.  

길이가 $n$인 배열을 병합 정렬한다. 배열의 $0$번째 요소를 가리키는 인덱스가 $left$고 배열의 $(n-1)$번째 요소를 가리키는 인덱스가 $right$라고 하자. 그 배열을 2개로 분할했을 때 분할된 첫 번쨰 배열의 끝을 가리키는 인덱스는 $\frac{left+right}{n}$이고 분할된 두 번쨰 배열이 처음을 가리키는 인덱스는 $\frac{left+right}{n}+1$이다. 

$$ 
\left [ left,right \right ] 
$$
$$ 
\left [ left,\frac{left+right}{n} \right ]\left [ \frac{left+right}{n}+1,right \right ] 
$$


임의의 상수 $m$이 있다고 했을 때 $left$와 $right$가 각각 $m$과 $m+1$이 될 때까지 분할한다. 만약 $left$가 $m$고 $right$가 $m+1$이 됐다고 했을 때 배열을 다시 분할하면,  

$$ 
\begin{align*}
& \left [ m,\frac{m+(m+1)}{n} \right ]\left [ \frac{m+(m+1)}{n}+1,m+1 \right ] \\
& = \left [ m,m+\frac{1}{2} \right ]\left [ m+\frac{3}{2},m+1 \right ] 
\end{align*}
$$

배열의 요소는 자연수이기 때문에,

$$ 
\left [ m, m \right ]\left [ m+1, m+1 \right ] 
$$

위와 같이 이미 어떤 인덱스가 배열의 요소를 가리키고 있었는데 새로 생긴 인덱스가 또 같은 요소를 가리키고 있어서 중복되어 분할하는 의미가 없어진다.


병합 정렬의 시간복잡도는 다음과 같다.

$$ O\left ( nlog_{2}n \right ) $$