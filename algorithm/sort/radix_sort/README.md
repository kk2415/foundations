# 기수 정렬(Radix Sort) 알고리즘
## 소스 컴파일
```
sudo apt-get update
sudo apt-get install libglib2.0-de
```
```
gcc -o radix_sort radix_sort.c `pkg-config --cflags --libs glib-2.0` -lm
```

## 설명
기수 정렬(Radix Sort)은 비교 기반 정렬 알고리즘이 아니며, 데이터의 개별 자릿수를 기준으로 정렬하는 방법이다. 이 알고리즘은 주로 정수나 문자열 같은 고정된 길이의 데이터에 유용하다. 기수 정렬은 LSD (Least Significant Digit)와 MSD (Most Significant Digit) 두 가지 방법으로 구현될 수 있다. 여기서는 더 일반적인 LSD 방식을 설명한다.

버킷(Bucket)을 큐 자료구조 배열이라고 할 때
버킷(Bucket)의 길이를 기수(Radix)로 놓는다. 10진법이면 버킷 길이를 10, 2진법이면 버킷 길이를 2로 놓음.  

각 정렬 대상들(숫자 혹은 문자열)의 첫 번째 자리부터 n번째 자리까지 오른쪽에서 왼쪽으로 차례대로 이동한다. "134", "122" 두 숫자를 정렬한다고 했을 때, 우선 첫 번째 자리수를 살펴보면 각각 "4"와 "2"가 첫 번째 자리수이다. 때문에 "134"는 버킷의 4번째 요소에 들어가고 "122"는 버킷의 2번째 요소에 들어간다.  

버킷으로의 이동이 한 차례 끝났으면 남은 일은 버킷 0에 저장된 것부터 시작해서 버킷 n의 저장된 것까지 순서대로 꺼내서 차례대로 나열만 하면 된다. 하나의 버킷에 둘 이상의 데이터가 존재하는 경우 들어간 순서대로 꺼내면 된다. 버킷의 각 요소가 큐 자료구조인 이유는 이것 때문이다. 들어간 순서대로 그대로 나와야한다.

digit이 표현할 수 있는 범위는 기수를 넘어설 수 없으니 버킷 길이가 부족할 일은 없다. 기수가 10이면 각 자리수가 표현할 수 있는 범위는 0~9이고 버킷 길이는 10이니까 배열 범위를 넘어설 일은 없다.

## 시간복잡도
기수 정렬의 시간복잡도는 다른 정렬 알고리즘과 다르게 비교연산을 기준으로 잡지 않는다. 큐 자료구조에 데이터가 삽입되고 추출되는 횟수가 기준이다. 따라서 기수 정렬의 시간복잡도는 삽입과 추출의 빈도수를 대상으로 결정해야 한다.

$$
\left [1,2,3,4,555555  \right ]
$$

배열의 길이가 $n$이고 숫자의 길이를 $l$이라고 했을 때 옆에 있는 배열은 $n=5$고 $l=6$이다. 배열의 모든 요소를 버킷에 담아야 하니 삽입과 추출 횟수는 $n$이고 이 작업을 $l$번 만큼 반복한다. 연산의 수행 횟수는 다음과 같다

$$
n \times l
$$

시간복잡도에 대한 기수 정렬의 빅-오는 다음과 같다.

$$
O\left(ln\right)
$$

물론 이는 다음과 같이도 볼 수 있다.

$$
O\left(n\right)
$$